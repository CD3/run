#!/usr/bin/perl -w
=head1 NAME

run - Quickly queue and run jobs from the command line.

=head1 DESCRIPTION

C<run> tries to run a set of commands using different handlers. It is primarily useful for running commands
that are expected to run for a long time, such as physics simulations, and it attempts to find a handler
that will complete all commands as quickly as possible. For example, if you are working on
a cluster and the qsub command exists, C<run> will create submission scripts and submit them to the scheduler.
If the qsub command does not exist, then other handlers are checked. For example, if the parallel command
exists (gnu parallel), it is used to run all commands in parallel.

If all other handlers fail, C<run> will fall back to just running each command in serial, one after the other.
This turns out to still be useful, because if you have a set of simulations that you need to perform, you can
use C<run> to automatically run each simulation after one has completed.

All handlers will first create a script wrapper for each command to run and then run this script.
This is done so that extra information can be embedded in the command output, such as a times tamp for timing data.


=head2 Current Handlers

=over

=item C<qsub>

This handler uses the C<qsub> command. C<qsub> is used to submit jobs to several HPC
schedulers including PBS, MOAB, and SGE. The qsub handler will automatically
create a submission script for each job and subit the scripts to the scheduler.
This is handy if you want to just quickly submit a basic job that does not
require a complex submission script.

=item C<gnuparallel>

This handler uses the C<parallel> command, from the gnuparallel project. C<parallel> is a
perl script that runs multiple jobs in parallel and even supports running jobs on remote computers
(not supported by run). It attempts to work as a parallel version of C<xargs>.

=item C<xjobs>

This handler uses the C<xjobs> command. It strives to be a parallel version of xargs.

=item C<serial>

This handler just runs each job directly, one after the other.

=back

=head2 Possible Future Handlers

=over

=item C<pexec>

=back

Note that C<run> does not do load balancing. Each handler is given the list of commands to run, and they are responsible
for managing the system workload.

=head1 USAGE

  > run cmd1 [args] [: cmd2 [args] [...] ]

=head2 OPTIONS:

=over

=item C<-h> 

this help message.

=item C<-V LEVEL>

set verbose level to LEVEL.
  
=item C<-v>

enable verbose level 1.

=item C<-n>

dry run. don't execute handler commands, just print them to stdout.

=item C<-H HANDLER>

specify the HANDLER to use.

=item C<-O HANDLER_OPTIONS>

pass a list of options to the handler command.

=item C<-l>

list supported handlers.

=item C<-C CMD>

prepend CMD to all commands before running.

=item C<-d DEL>

use DEL to delimiter commands (default '$arg_delim').

=item C<-w HH:MM:SS>

maximum walltime for jobs. this is only used for handlers that submit jobs to a scheduler.

=item C<-o>

send standard output to files. note that what happens here depends on the handler. some
handlers create a separate file for each command ran, some put all the stdout of all commands
in the same file, while others ignore this option all together and always space stdout in files.

=item C<-f>

leave the generated wrapper script in the current working directory.

=item C<-F>

treat all arguments as the names of already existing wrapper scripts and run directly without generating new wrapper scripts.

=back

=head1 EXAMPLES

run 3 scripts

    > run script1.sh : script2.sh : script3.sh

run 3 BTEC runs

    > run -C BTECthermal config1.btec : config2.btec : config3.btec

run BTEC for all config files in the current directory

    > run -C BTECthermal -d' ' config*.btec

run 3 scripts using the gnuparallel handler

    > run -H gnuparallel script1.sh : script2.sh : script3.sh

first create run scripts for three commands, then run these scripts.

    > run -f cmd1 : cmd2 : cmd3
    > run -F run_script-*.sh

get a list of all handlers

    > run -l

=head1 INSTALLATION

C<run> is a single perl script. To install it, just place it somewhere in your PATH.

=head2 DEPENDENCIES

C<run> only uses a few standard Perl modules. These modules should be installed with Perl
and it should not be necessary to install any additional modules.

In addition to this, a few standard Linux commands are used, such as C<cp> and C<chmod>.

=cut

use File::Temp qw/tempfile tempdir/;
use File::Basename;
use Getopt::Std;
use Cwd;



#       _       _           _                       
#  __ _| | ___ | |__   __ _| | __   ____ _ _ __ ___ 
# / _` | |/ _ \| '_ \ / _` | | \ \ / / _` | '__/ __|
#| (_| | | (_) | |_) | (_| | |  \ V / (_| | |  \__ \
# \__, |_|\___/|_.__/ \__,_|_|   \_/ \__,_|_|  |___/
# |___/                                             

$debug = 0;

my $version = '0.1.0';

%scheduler_templates = (
             'name' => { 'SGE'  => '#$ -N %s'
                       , 'PBS'  => '#PBS -N %s'
                       , 'MOAB' => '#MOAB -N %s' }

           , 'walltime' => { 'SGE'  => '#$ -l h_rt=%s'
                           , 'PBS'  => '#PBS -l walltime=%s'
                           , 'MOAB' => '#MOAB -l walltime=%s' }

           , 'shell' => { 'SGE'  => '#$ -S /bin/bash'
                        , 'PBS'  => ''
                        , 'MOAB' => '' }

           , 'cwd'   => { 'SGE'  => '#$ -cwd'
                        , 'PBS'  => ''
                        , 'MOAB' => '' }

           , 'mergeout'   => { 'SGE'  => '#$ -j y'
                             , 'PBS'  => '#PBS -j oe'
                             , 'MOAB' => '#MOAB -j oe' }
             );

$shebang = "#! ".`which bash`;

$verbose_level = 0;

$arg_delim = ":";

$date_fmt = "%Y%m%d %H:%M:%S";

$script_prefix = "run_script-";
$script_suffix = ".sh";

$stdoutfn_tmpl = "run-%s.o%d";
#$stderrfn_tmpl = "run-%s.e%d";

#           _                     _   _                 
# ___ _   _| |__  _ __ ___  _   _| |_(_)_ __   ___  ___ 
#/ __| | | | '_ \| '__/ _ \| | | | __| | '_ \ / _ \/ __|
#\__ \ |_| | |_) | | | (_) | |_| | |_| | | | |  __/\__ \
#|___/\__,_|_.__/|_|  \___/ \__,_|\__|_|_| |_|\___||___/
                                                       

sub write_readme
{
  system("perldoc -u $0 > README.pod");
}

sub usage()
{
  system("perldoc $0");
}



sub cmd_exists
{
  my $cmd = shift;
  my $e = system("which $cmd > /dev/null 2>&1");

  return !$e;
}


sub build_skel_script
{
  my ($CMD) = @_;
  my @lines = ();

  push @lines, $shebang."\n";
  push @lines, "cd ".getcwd()."\n";
  push @lines, "echo 'CMD: $CMD'\n";
  push @lines, "echo -n 'BEGIN: '";
  push @lines, "date +'$date_fmt'\n";
  push @lines, "$CMD\n";
  push @lines, "echo -n 'END:   '";
  push @lines, "date +'$date_fmt'\n";

  return @lines;
}


sub write_script
{
  my    $scriptfn = "${tempdir}/${script_prefix}${cmdi}${script_suffix}";
  open( $scriptfh,">".$scriptfn) or die "could not write submit script to temp file";
  print $scriptfh join( "\n", @_ )."\n";
  close($scriptfh);

  return $scriptfn;
}


sub generate_name_for_cmd
{
  my $CMD = join(" ",@_);
  my $name = $CMD;
  $name =~ s/\/+/-/g;
  $name =~ s/ +/__/g;
  $name =~ s/^\./_/g;
  $name =~ s/^[-\.]//g;

  return $name;
}


sub message
{
  my $level = shift;
  print "MSG($level): ".join " ", @_  if( $level <= $verbose_level );
}


# _                     _ _               
#| |__   __ _ _ __   __| | | ___ _ __ ___ 
#| '_ \ / _` | '_ \ / _` | |/ _ \ '__/ __|
#| | | | (_| | | | | (_| | |  __/ |  \__ \
#|_| |_|\__,_|_| |_|\__,_|_|\___|_|  |___/
                                         
# all handlers need to follow a special convension:
# - if called with no arguments, return true if the handler can handle
# remember that shell commands return 0 ON SUCESS.


# _                       _       _            
#| |_ ___ _ __ ___  _ __ | | __ _| |_ ___  ___ 
#| __/ _ \ '_ ` _ \| '_ \| |/ _` | __/ _ \/ __|
#| ||  __/ | | | | | |_) | | (_| | ||  __/\__ \
# \__\___|_| |_| |_| .__/|_|\__,_|\__\___||___/
#                  |_|                         


sub HDLR_generate_scripts {
}
sub HDLR_run_scripts {
}
sub HDLR {
}

#                 _     
#  __ _ ___ _   _| |__  
# / _` / __| | | | '_ \ 
#| (_| \__ \ |_| | |_) |
# \__, |___/\__,_|_.__/ 
#    |_|                

sub qsub_generate_scripts {
  # we need to figure out what scheduler is running so we can create the correct
  # script
  my $scheduler = "UNKNOWN";

  $scheduler = "PBS"  if( cmd_exists( "pbsnodes" ) );
  $scheduler = "MOAB" if( cmd_exists( "moabnodes" ) );
  $scheduler = "SGE"  if( cmd_exists( "sge_qmaster" ) );

  message( 1, "Scheduler detected: $scheduler");

  my @scripts = ();

  $cmdi = 0;
  for $CMD (@_)
  {
    $cmdi = $cmdi+1;

    # generate the script that we will submit.
    my @lines = build_skel_script( $CMD );
    my @scheduler_conf = ();

    my $name = generate_name_for_cmd($CMD);

    push @scheduler_conf, sprintf( $scheduler_templates{name    }->{$scheduler}, $name );
    push @scheduler_conf, sprintf( $scheduler_templates{walltime}->{$scheduler}, $walltime );
    push @scheduler_conf, sprintf( $scheduler_templates{shell   }->{$scheduler}, "bash" );
    push @scheduler_conf, sprintf( $scheduler_templates{cwd     }->{$scheduler} );
    push @scheduler_conf, sprintf( $scheduler_templates{mergeout}->{$scheduler} );

    # add the scheduler configuration after the shebang, but before everything else
    splice @lines, 1, 0, @scheduler_conf;

    push @scripts, write_script( @lines );

  }

  return @scripts;
}

sub qsub_run_scripts {

  for my $scriptfn (@_)
  {
    my $cmd_to_run = "qsub $opt_O $scriptfn";
    system($cmd_to_run     ) if( not $opt_n );
    print( $cmd_to_run."\n") if(     $opt_n );
  }
}

sub qsub {
  if( scalar @_ == 0 ) {
    # first of all, the qsub command needs to exist
    my $e = cmd_exists('qsub');
    
    return 0 if( not $e );

    # but, just because the qsub command exists, does not mean
    # it will work. we can try to submit simple job through the
    # standard input.
    $e = system('echo "hostname" | qsub > /dev/null 2>&1');

    return 0 if( $e );

    # the qsub command exists, and it appears to be accepting commands,
    # so it looks like we can give it the OK.
    return 1;
  }

  # generate all the scripts first
  # generate all the scripts first
  if( $opt_F )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @_;
  }
  else
  {
    @scripts = qsub_generate_scripts(@_);
  }

  # now run them
  qsub_run_scripts(@scripts);
}


#                                           _ _      _ 
#  __ _ _ __  _   _   _ __   __ _ _ __ __ _| | | ___| |
# / _` | '_ \| | | | | '_ \ / _` | '__/ _` | | |/ _ \ |
#| (_| | | | | |_| | | |_) | (_| | | | (_| | | |  __/ |
# \__, |_| |_|\__,_| | .__/ \__,_|_|  \__,_|_|_|\___|_|
# |___/              |_|                               

sub gnuparallel_generate_scripts {

  my @scripts = ();
  $cmdi = 0;
  for $CMD (@_)
  {
    $cmdi = $cmdi+1;

    my @lines = build_skel_script( $CMD );
    my $scriptfn = write_script( @lines );
    system("chmod +x ".$scriptfn);
    push @scripts, $scriptfn;
  }

  return @scripts;
}

sub gnuparallel_run_scripts {

  # parallel runs a command with different arguments pulled from groups that are separated by :::
  #
  # parallel cmd ::: arg1 arg2 arg3
  #
  # if no command is given, then each argument is treated as a command ran ran
  #
  # parallel ::: cmd1 cmd2 cmd3
  #
  # if the --files option is given, then the standard output of each command is sent to a file
  # instead of the screen. however, we don't know the name of this file before hand, parallel
  # will print it to stdout as they are created.
  #
  my $cmd_to_run  = "parallel $opt_O".($opt_o ? "--files" : "" )." ::: ".join(" ", @_);

  if( $opt_n )
  {
    print( $cmd_to_run."\n");
  }
  else
  {
    # we wan to send stdout to files
    if( $opt_o )
    {
      # parallel will print out a list of the files that it sends the stdout to.
      # we need to get this list and move these files.
      my @files = `$cmd_to_run`;
      chomp(@files);

      my $i = 0;
      for my $file (@files)
      {
        $i++;

        # the command ran in each script is printed to stdout, so we can retrieve
        # it from each stdout file written by parallel
        my $cmd = "UNKNOWN";
        open(FILE, "<$file");
        my @cmd_line = grep(/CMD:/, <FILE>);
        close(FILE);
        if( $cmd_line[0] =~ /^CMD:\s(.*)$/ )
        {
          $cmd = $1;
        }

        my $name = generate_name_for_cmd($cmd);
        my $stdoutfn = sprintf($stdoutfn_tmpl, $name, ${i} );
        system("cat $file >> $stdoutfn 2>&1");
      }
    }
    else
    {
      # we can just run the command
      system($cmd_to_run)
    }
  }

}

sub gnuparallel {
  if( scalar @_ == 0 ) {
    return cmd_exists('parallel');
  }

  # generate all the scripts first
  if( $opt_F )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @_;
  }
  else
  {
    @scripts = gnuparallel_generate_scripts(@_);
  }

  # now run them
  gnuparallel_run_scripts(@scripts);


}


#       _       _         
#__  __(_) ___ | |__  ___ 
#\ \/ /| |/ _ \| '_ \/ __|
# >  < | | (_) | |_) \__ \
#/_/\_\/ |\___/|_.__/|___/
#    |__/                 

sub xjobs_generate_scripts {
  # turns out, we can just use the scripts we would use for gnuparrallel
  return gnuparallel_generate_scripts(@_);
}

sub xjobs_run_scripts {

  my $cmd_to_run = "echo '".join("\n", @_)."' | xjobs $opt_O";
  my $stdoutfn = sprintf($stdoutfn_tmpl, "X", "1" );
     $cmd_to_run .= "> $stdoutfn" if( $opt_o );
  if( $opt_n )
  {
    print( $cmd_to_run."\n");
  }
  else
  {
    system($cmd_to_run);
  }

}

sub xjobs {
  if( scalar @_ == 0 ) {
    return cmd_exists('xjobs');
  }

  # generate all the scripts first
  if( $opt_F )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @_;
  }
  else
  {
    @scripts = xjobs_generate_scripts(@_);
  }

  # now run them
  xjobs_run_scripts(@scripts);


}


#               _       _ 
# ___  ___ _ __(_) __ _| |
#/ __|/ _ \ '__| |/ _` | |
#\__ \  __/ |  | | (_| | |
#|___/\___|_|  |_|\__,_|_|
                         

sub serial_generate_scripts {
  my @scripts = ();

  $cmdi = 0;
  for $CMD (@_)
  {
    $cmdi = $cmdi+1;

    my $name = generate_name_for_cmd($CMD);

    my @lines = build_skel_script( $CMD );
    my $scriptfn = write_script( @lines );
    system("chmod +x ".$scriptfn);

    push @scripts, $scriptfn;

  }

  return @scripts;
}

sub serial_run_scripts {

  $cmdi = 0;
  for $scriptfn (@_)
  {
    $cmdi++;
    # the script will echo the command that it runs, so we can easily pull out the command
    my $cmd = "UNKNOWN";
    open(FILE, "<$scriptfn");
    my @cmd_line = grep(/echo 'CMD:/, <FILE>);
    close(FILE);
    if( $cmd_line[0] =~ /^echo 'CMD:\s(.*)'$/ )
    {
      $cmd = $1;
    }
    my $name = generate_name_for_cmd($cmd);
    my $stdoutfn = "_run-${name}.o${cmdi}";
    my $cmd_to_run  = $scriptfn . ($opt_o ? " >> ${stdoutfn}" : "" );

    system($cmd_to_run     ) if( not $opt_n );
    print( $cmd_to_run."\n") if(     $opt_n );
  }
}

sub serial {
  if( scalar @_ == 0 ) {
    return 1; # this one will always work
  }

  # generate all the scripts first
  my @scripts = ();
  if( $opt_F )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @_;
  }
  else
  {
    @scripts = serial_generate_scripts(@_);
  }

  # now run them
  serial_run_scripts(@scripts);

}










my @handlers  = (
                  { name => "qsub"         , func => \&qsub        , help => "submit jobs to a scheduler" } ,
                  { name => "gnuparallel"  , func => \&gnuparallel , help => "run jobs using the the gnu parallel script" } ,
                  { name => "xjobs"        , func => \&xjobs       , help => "run jobs using the xjobs utility." } ,
                  { name => "serial"       , func => \&serial      , help => "run jobs one after the other" } ,
                );

#             _   _               _                     _ _ _             
#  ___  _ __ | |_(_) ___  _ __   | |__   __ _ _ __   __| | (_)_ __   __ _ 
# / _ \| '_ \| __| |/ _ \| '_ \  | '_ \ / _` | '_ \ / _` | | | '_ \ / _` |
#| (_) | |_) | |_| | (_) | | | | | | | | (_| | | | | (_| | | | | | | (_| |
# \___/| .__/ \__|_|\___/|_| |_| |_| |_|\__,_|_| |_|\__,_|_|_|_| |_|\__, |
#      |_|                                                          |___/ 

our(
   $opt_h  # help
  ,$opt_l  # list handlers
  ,$opt_H  # use handler specific handler
  ,$opt_O  # pass options to handler
  ,$opt_v  # turn on verbose
  ,$opt_V  # set verbose level
  ,$opt_D  # debug mode
  ,$opt_n  # dry run, don't execute commands, just 
  ,$opt_o  # send stdout to files
  ,$opt_w  # set walltime
  ,$opt_f  # leave script files in current working directory
  ,$opt_F  # dont generate run scripts, just run all arguments as run scripts
  ,$opt_R  # write README.md
   );

getopt('HOVCdw');

# help
if($opt_h)
{
  usage();
  exit(0);
}
if($opt_R)
{
  write_readme();
  exit(0);
}
if($opt_n)
{
  print "Dry Run. Will just print commands that would be executed instead of executing them.\n";
  print "Note that this ma not help much if a temporary script is going to be created an ran.\n\n";
}

$debug         = 1      if ($opt_D);
$opt_v         = $opt_V if ($opt_V);
$verbose_level = $opt_v if ($opt_v);
$verbose_level = 100    if ($debug);
$opt_O         = "" unless ($opt_O);


if($opt_l)
{
  foreach $hdlr ( @handlers )
  {
    print $hdlr->{name}."\t\t- ".$hdlr->{help}."\n";
  }

  exit(0);
}

$opt_d = ' ' if($opt_F);
$arg_delim = $opt_d if($opt_d);

$walltime = $opt_w  ? $opt_w : "10:00:00";






#                 _       
# _ __ ___   __ _(_)_ __  
#| '_ ` _ \ / _` | | '_ \ 
#| | | | | | (_| | | | | |
#|_| |_| |_|\__,_|_|_| |_|

$tempdir = tempdir(CLEANUP => $debug ? 0 : 1) or die "Cannot make temp dir.  Unable to proceed - aborting.";
                         
# get array of commands that need to be ran
@CMDS = split( /\s*$arg_delim\s*/, join(' ', @ARGV) );

# if the -C option was given, then we want to prepend its argument to all commands

if( $opt_C )
{
  @CMDS = map { $opt_C." ".$_} @CMDS;
}



# try to figure out what options we have.
undef $handler;
if($opt_H)
{
  $handler_name = $opt_H;
  for $hdlr (@handlers)
  {
    if( $hdlr->{name} =~ /$handler_name/ )
    {
      $handler = $hdlr
    }
  }

  if( not defined($handler) )
  {
    print "ERROR: '$handler_name' handler not found. Did you misspell it? Use -l option to see a list of supported handlers";
    exit(1);
  }
}
else
{
  foreach $hdlr ( @handlers )
  {
     message(2, "Checking '$hdlr->{name}' handler..." );
     if( $hdlr->{'func'}->() )
     {
       message(2, "valid\n"  );
       $handler = $hdlr;
       last;
     }
     message(2, "invalid\n"  );
  }
}

if( not defined($handler) )
{
  print "ERROR: no handler was found. Something is wrong\n";
  exit(1);
}

message(1, "Running with '$handler->{name}' handler\n");
if( $debug )
{
  print "running the following commands:\n";
  for my $CMD (@CMDS)
  {
    print "\t'$CMD'\n"
  }
}

$handler->{func}->(@CMDS);

if( $opt_f )
{
  # all scripts will be in tempdir and have the script_prefix.
  system("cp ${tempdir}/${script_prefix}*${script_suffix} ./");
}


exit(0);

