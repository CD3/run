#!/usr/bin/perl -w

use File::Temp qw/tempfile tempdir/;
use File::Basename;
use File::Copy;
use Pod::Usage;
use Getopt::Long qw(:config no_ignore_case);
use Cwd;
use Data::Dumper;



#       _       _           _                       
#  __ _| | ___ | |__   __ _| | __   ____ _ _ __ ___ 
# / _` | |/ _ \| '_ \ / _` | | \ \ / / _` | '__/ __|
#| (_| | | (_) | |_) | (_| | |  \ V / (_| | |  \__ \
# \__, |_|\___/|_.__/ \__,_|_|   \_/ \__,_|_|  |___/
# |___/                                             

$debug = 0;

%run_script_templates = ();

$run_script_templates{'serial'} = <<'EOF';
<%SHEBANG%>

cd <%WORKDIR%>
echo "CMD: <%CMD%>"
echo "ARGS: <%ARGS%>"
echo -n "BEGIN: "
date +"%Y%m%d %H:%M:%S"
<%CMD%> <%ARGS%>
echo -n "END:   "
date +%"Y%m%d %H:%M:%S"
EOF

$run_script_templates{'htcondor'} = <<'EOF';
Universe   = vanilla
Executable = <%CMD%>
Log        = <%NAME%>.log
Output     = <%NAME%>.$(Process).out
Error      = <%NAME%>.$(Process).error

# Arguments  = <%ARGS%>
# Queue
#
# Arguments and Queue commands will be appended rather
# than rendered.
EOF

$run_script_templates{'PBS'} = <<'EOF';
<%SHEBANG%>

#PBS -N <%NAME%>
#PBS -j oe

<%SERIAL%>

EOF

$run_script_templates{'SGE'} = <<'EOF';
<%SHEBANG%>

#$ -N <%NAME%>
#$ -j y
#$ -S <%SHELL%>
#$ -cwd

<%SERIAL%>

EOF

$run_script_templates{'MOAB'} = <<'EOF';
<%SHEBANG%>

#MOAB -N <%NAME%>
#MOAB -j oe

<%SERIAL%>

EOF

$shell = `which bash` =~ s/\s*$//gr;
$shebang = "#! ".$shell;

$verbose_level = 0;

$arg_delim = ":";

$script_prefix = "run_script-";
$script_suffix = ".sh";

$stdoutfn_tmpl = "run-%s.o%d";
#$stderrfn_tmpl = "run-%s.e%d";

#           _                     _   _                 
# ___ _   _| |__  _ __ ___  _   _| |_(_)_ __   ___  ___ 
#/ __| | | | '_ \| '__/ _ \| | | | __| | '_ \ / _ \/ __|
#\__ \ |_| | |_) | | | (_) | |_| | |_| | | | |  __/\__ \
#|___/\__,_|_.__/|_|  \___/ \__,_|\__|_|_| |_|\___||___/
                                                       

sub write_readme
{
  system("perldoc -u $0 > README.pod");
}

sub read_file
{
  my ($filename) = @_;
  my $script = "";
  open(my $fh, '<', $filename) or die "Cannot open file $filename";
  {
    local $/;
    $script = <$fh>;
  }
  close($fh);

  return $script;
}


sub cmd_exists
{
  my $cmd = shift;
  my $e = system("which $cmd > /dev/null 2>&1");

  return !$e;
}

sub render_serial_script {

  my ($CMDANDARGS) = @_;

  my($cmd,$args) = split /\s/, $CMDANDARGS, 2;
  $args = "" if(!$args);
  my $cwd = getcwd();

  my $name = generate_name_for_cmd($CMDANDARGS);

  my $script = $run_script_templates{serial};
  $script = read_file($opt_template) if( defined( $opt_template ) );

  $script =~ s/<%SHEBANG%>/$shebang/g;
  $script =~ s/<%WORKDIR%>/$cwd/g;
  $script =~ s/<%CMD%>/$cmd/g;
  $script =~ s/<%ARGS%>/$args/g;

  return $script;
}


sub write_script
{
  my( $cmdi, @lines) = @_;

  my    $scriptfn = "${tempdir}/${script_prefix}${cmdi}${script_suffix}";
  open( $scriptfh,">".$scriptfn) or die "could not write submit script to temp file";
  print $scriptfh join( "\n", @lines )."\n";
  close($scriptfh);

  return $scriptfn;
}


sub generate_name_for_cmd
{
  my $CMD = join(" ",@_);
  my $name = "_".$CMD;
  # replace all special characters
  $name =~ s/\/+/--/g;
  $name =~ s/[^a-zA-Z0-9]/_/g;

  # if the filename is longer than 40 characters, then
  # create an md5 sum instead.
  $name = "_".(split / /, `echo $CMD | md5sum`)[0] if( length $name > 40 );

  return $name;
}


sub message
{
  my $level = shift;
  print "MSG($level): ".join " ", @_  if( $level <= $verbose_level );
}


# _                     _ _               
#| |__   __ _ _ __   __| | | ___ _ __ ___ 
#| '_ \ / _` | '_ \ / _` | |/ _ \ '__/ __|
#| | | | (_| | | | | (_| | |  __/ |  \__ \
#|_| |_|\__,_|_| |_|\__,_|_|\___|_|  |___/
                                         
# all handlers need to follow a special convension:
# - if called with no arguments, return true if the handler can handle
# remember that shell commands return 0 ON SUCESS.


# _                       _       _            
#| |_ ___ _ __ ___  _ __ | | __ _| |_ ___  ___ 
#| __/ _ \ '_ ` _ \| '_ \| |/ _` | __/ _ \/ __|
#| ||  __/ | | | | | |_) | | (_| | ||  __/\__ \
# \__\___|_| |_| |_| .__/|_|\__,_|\__\___||___/
#                  |_|                         


sub HDLR_generate_scripts {
}
sub HDLR_run_scripts {
}
sub HDLR {
}

#                 _     
#  __ _ ___ _   _| |__  
# / _` / __| | | | '_ \ 
#| (_| \__ \ |_| | |_) |
# \__, |___/\__,_|_.__/ 
#    |_|                

sub qsub_generate_scripts {
  my ($args) = @_;

  # we need to figure out what scheduler is running so we can create the correct
  # script
  my $scheduler = "UNKNOWN";

  $scheduler = "PBS";
  $scheduler = "PBS"  if( cmd_exists( "pbsnodes" ) );
  $scheduler = "MOAB" if( cmd_exists( "moabnodes" ) );
  $scheduler = "SGE"  if( cmd_exists( "sge_qmaster" ) );
  $scheduler = $args->{args}->[0] if( scalar @{$args->{args}} );

  message( 1, "Scheduler detected: $scheduler\n");

  my @scripts = ();

  $cmdi = 1;
  for $CMD (@{$args->{cmds}})
  {
    # generate the script that we will submit.

    my $name   = generate_name_for_cmd($CMD);
    my $script = $run_script_templates{$scheduler};
    $script = read_file($opt_template) if( defined( $opt_template ) );
    my $shebang_save = $shebang;
    $shebang = "";
    my $serial_script = render_serial_script( $CMD );
    $shebang = $shebang_save;

    $script =~ s/<%SHEBANG%>/$shebang/g;
    $script =~ s/<%NAME%>/$name/g;
    $script =~ s/<%SHELL%>/$shell/g;
    $script =~ s/<%SERIAL%>/$serial_script/g;
    $script =~ s/<%CMD%>/$CMD/g;
    $script =~ s/<%ARGS%>/"/g;

    push @scripts, write_script( $cmdi++, $script );

  }

  return @scripts;
}

sub qsub_run_scripts {

  for my $scriptfn (@_)
  {
    my $cmd_to_run = "qsub $opt_handler_options $scriptfn";
    system($cmd_to_run     ) if( not $opt_dry_run );
    print( $cmd_to_run."\n") if(     $opt_dry_run );
  }
}

sub qsub {
  my ($args) = @_;
  if( scalar @{$args->{cmds}} == 0 ) {
    # first of all, the qsub command needs to exist
    my $e = cmd_exists('qsub');
    
    return 0 if( not $e );

    # but, just because the qsub command exists, does not mean
    # it will work. we can try to submit simple job through the
    # standard input.
    unless($opt_dont_test_for_handler)
    {
      $e = system('echo "hostname" | qsub > /dev/null 2>&1');

      return 0 if( $e );
    }

    # the qsub command exists, and it appears to be accepting commands,
    # so it looks like we can give it the OK.
    return 1;
  }

  # generate all the scripts first
  if( $opt_args_are_run_scripts )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @{$args->{cmds}};
  }
  else
  {
    @scripts = qsub_generate_scripts($args);
  }

  # now run them
  qsub_run_scripts(@scripts);

  # if the block option is set
  # block until all jobs have finished
  if( $opt_block )
  {
    my $jobs = join ",", map { generate_name_for_cmd($_); } @{$args->{cmds}};
    my $wait = 1;
    while( $wait )
    {
      # sleep for 10 seconds
      sleep(10);
      my $out = `qstat -j $jobs`;
      $wait = 0 unless( $out =~ /^job_number:/m );
    }
  }

}


#                                           _ _      _ 
#  __ _ _ __  _   _   _ __   __ _ _ __ __ _| | | ___| |
# / _` | '_ \| | | | | '_ \ / _` | '__/ _` | | |/ _ \ |
#| (_| | | | | |_| | | |_) | (_| | | | (_| | | |  __/ |
# \__, |_| |_|\__,_| | .__/ \__,_|_|  \__,_|_|_|\___|_|
# |___/              |_|                               

sub gnuparallel_generate_scripts {

  my @scripts = ();
  $cmdi = 1;
  for $CMD (@_)
  {
    my $script = render_serial_script($CMD);
    my $scriptfn = write_script($cmdi++,$script);
    chmod 0755, $scriptfn;
    push @scripts, $scriptfn;
  }

  return @scripts;
}

sub gnuparallel_run_scripts {

  # parallel runs a command with different arguments pulled from groups that are separated by :::
  #
  # parallel cmd ::: arg1 arg2 arg3
  #
  # if no command is given, then each argument is treated as a command and ran
  #
  # parallel ::: cmd1 cmd2 cmd3
  #
  # if the --files option is given, then the standard output of each command is sent to a file
  # instead of the screen. however, we don't know the name of this file before hand, parallel
  # will print it to stdout as they are created.
  #
  my $cmd_to_run  = "parallel $opt_handler_options".($opt_output ? "--files" : "" )." ::: ".join(" ", @_);

  if( $opt_dry_run )
  {
    print( $cmd_to_run."\n");
  }
  else
  {
    # we wan to send stdout to files
    if( $opt_output )
    {
      # parallel will print out a list of the files that it sends the stdout to.
      # we need to get this list and move these files.
      my @files = `$cmd_to_run`;
      chomp(@files);

      my $i = 0;
      for my $file (@files)
      {
        $i++;

        # the command ran in each script is printed to stdout, so we can retrieve
        # it from each stdout file written by parallel
        my $cmd = "UNKNOWN";
        open(FILE, "<$file");
        my @cmd_line = grep(/CMD:/, <FILE>);
        close(FILE);
        if( $cmd_line[0] =~ /^CMD:\s(.*)$/ )
        {
          $cmd = $1;
        }

        my $name = generate_name_for_cmd($cmd);
        my $stdoutfn = sprintf($stdoutfn_tmpl, $name, ${i} );
        #system("cat $file >> $stdoutfn 2>&1");
        open(INFILE, "<$file");
        open(OUTFILE, ">>$stdoutfn");
        { local $/; print OUTFILE <INFILE>; }
        close(INFILE);
        close(OUTFILE);
      }
    }
    else
    {
      # we can just run the command
      system($cmd_to_run)
    }
  }

}

sub gnuparallel {
  my ($args) = @_;

  if( scalar @{$args->{cmds}} == 0 ) {
    return cmd_exists('parallel');
  }

  # generate all the scripts first
  if( $opt_args_are_run_scripts )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @{$args->{cmds}};
  }
  else
  {
    @scripts = gnuparallel_generate_scripts(@{$args->{cmds}});
  }

  # now run them
  gnuparallel_run_scripts(@scripts);


}


#       _       _         
#__  __(_) ___ | |__  ___ 
#\ \/ /| |/ _ \| '_ \/ __|
# >  < | | (_) | |_) \__ \
#/_/\_\/ |\___/|_.__/|___/
#    |__/                 

sub xjobs_generate_scripts {
  # turns out, we can just use the scripts we would use for gnuparrallel
  return gnuparallel_generate_scripts(@_);
}

sub xjobs_run_scripts {

  my $cmd_to_run = "echo '".join("\n", @_)."' | xjobs $opt_handler_options";
  my $stdoutfn = sprintf($stdoutfn_tmpl, "X", "1" );
     $cmd_to_run .= "> $stdoutfn" if( $opt_output );
  if( $opt_dry_run )
  {
    print( $cmd_to_run."\n");
  }
  else
  {
    system($cmd_to_run);
  }

}

sub xjobs {
  my ($args) = @_;

  if( scalar @{$args->{cmds}} == 0 ) {
    return cmd_exists('xjobs');
  }

  # generate all the scripts first
  if( $opt_args_are_run_scripts )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @{$args->{cmds}};
  }
  else
  {
    @scripts = xjobs_generate_scripts(@{$args->{cmds}});
  }

  # now run them
  xjobs_run_scripts(@scripts);


}

# _     _                      _            
#| |__ | |_ ___ ___  _ __   __| | ___  _ __ 
#| '_ \| __/ __/ _ \| '_ \ / _` |/ _ \| '__|
#| | | | || (_| (_) | | | | (_| | (_) | |   
#|_| |_|\__\___\___/|_| |_|\__,_|\___/|_|   
                                           

sub htcondor_generate_scripts {
  my ($args) = @_;

  my @scripts = ();


  # condor allows for the same command to be ran with multiple set of arguments.
  # we may want to 

  $cmdi = 1;
  for $CMDANDARGS (@{$args->{cmds}})
  {
    my($CMD,$ARGS) = split /\s/, $CMDANDARGS, 2;

    # generate the script that we will submit.
    my $name   = generate_name_for_cmd($CMDANDARGS);
    my $script = $run_script_templates{htcondor};
    $script = read_file($opt_template) if( defined( $opt_template ) );

    $script =~ s/<%SHEBANG%>/$shebang/g;
    $script =~ s/<%NAME%>/$name/g;
    $script =~ s/<%SHELL%>/$shell/g;
    $script =~ s/<%CMD%>/$CMD/g;

    $script .= "\n";
    $script .= "Arguments = $ARGS" if($ARGS);
    $script .= "\n";
    $script .= "Queue";
    $script .= "\n";

    push @scripts, write_script( $cmdi++, $script );

  }

  return @scripts;
}

sub htcondor_run_scripts {

  for my $scriptfn (@_)
  {
    my $cmd_to_run = "condor_submit $opt_handler_options $scriptfn";
    system($cmd_to_run     ) if( not $opt_dry_run );
    print( $cmd_to_run."\n") if(     $opt_dry_run );
  }
}

sub htcondor {
  my ($args) = @_;
  if( scalar @{$args->{cmds}} == 0 ) {
    # first of all, the condor_submit command needs to exist
    my $e = cmd_exists('condor_submit');
    
    return 0 if( not $e );

    # the condor_submit command exists
    return 1;
  }

  # generate all the scripts first
  if( $opt_args_are_run_scripts )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @{$args->{cmds}};
  }
  else
  {
    @scripts = htcondor_generate_scripts($args);
  }

  # now run them
  htcondor_run_scripts(@scripts);

  # if the block option is set
  # block until all jobs have finished
  if( $opt_block )
  {
    # TODO: Figure out how to block!
  }

}


#               _       _ 
# ___  ___ _ __(_) __ _| |
#/ __|/ _ \ '__| |/ _` | |
#\__ \  __/ |  | | (_| | |
#|___/\___|_|  |_|\__,_|_|
                         
sub serial_generate_scripts {
  my @scripts = ();

  $cmdi = 1;
  for $CMDANDARGS (@_)
  {
    $script = render_serial_script($CMDANDARGS);

    my $scriptfn = write_script($cmdi++,$script);
    chmod 0755, $scriptfn;
    push @scripts, $scriptfn;

  }

  return @scripts;
}

sub serial_run_scripts {

  for $scriptfn (@_)
  {
    my $stdoutfn = "_".basename $scriptfn.".o";
    my $cmd_to_run  = $scriptfn . ($opt_output ? " >> ${stdoutfn}" : "" );

    system($cmd_to_run     ) if( not $opt_dry_run );
    print( $cmd_to_run."\n") if(     $opt_dry_run );
  }
}

sub serial {
  my ($args) = @_;

  if( scalar @{$args->{cmds}} == 0 ) {
    return 1; # this one will always work
  }

  # generate all the scripts first
  my @scripts = ();
  if( $opt_args_are_run_scripts )
  {
    # if the script names does not contain a relative or absolute path, we need to add one.
    @scripts = map { s/^([^\/])/.\/$1/; $_ } @{$args->{cmds}};
  }
  else
  {
    @scripts = serial_generate_scripts(@{$args->{cmds}});
  }

  # now run them
  serial_run_scripts(@scripts);

}










my @handlers  = (
                  { name => "qsub"         , func => \&qsub        , help => "submit jobs to a scheduler" } ,
                  { name => "htcondor"     , func => \&htcondor    , help => "submit jobs to a condor pool" } ,
                  { name => "gnuparallel"  , func => \&gnuparallel , help => "run jobs using the the gnu parallel script" } ,
                  { name => "xjobs"        , func => \&xjobs       , help => "run jobs using the xjobs utility" } ,
                  { name => "serial"       , func => \&serial      , help => "run jobs one after the other" } ,
                );

#             _   _               _                     _ _ _             
#  ___  _ __ | |_(_) ___  _ __   | |__   __ _ _ __   __| | (_)_ __   __ _ 
# / _ \| '_ \| __| |/ _ \| '_ \  | '_ \ / _` | '_ \ / _` | | | '_ \ / _` |
#| (_) | |_) | |_| | (_) | | | | | | | | (_| | | | | (_| | | | | | | (_| |
# \___/| .__/ \__|_|\___/|_| |_| |_| |_|\__,_|_| |_|\__,_|_|_|_| |_|\__, |
#      |_|                                                          |___/ 


our(
  $opt_help,
  $opt_manual,
  $opt_block,
  $opt_debug,
  $opt_delimiter,
  $opt_args_are_run_scripts,
  $opt_leave_run_scripts,
  $opt_handler,
  $opt_handler_options,
  $opt_list_handlers,
  $opt_dry_run,
  $opt_output,
  $opt_readme,
  $opt_templateemplate,
  $opt_dont_test_for_handler,
  $opt_verbose,
  );

$opt_verbose = 0;

if( ! scalar @ARGV )
{
  pod2usage(-verbose => 0, -output => \*STDOUT);
}

GetOptions( "help|h" => \$opt_help,
            "manual|m" => \$opt_manual,
            "debug|D" => \$opt_debug,
            "delimiter|d" => \$opt_delimiter,
            "block|B" => \$opt_block,
            "command|C" => \$opt_command,
            "args-are-run-scripts|F" => \$opt_args_are_run_scripts,
            "leave-run-scripts|f" => \$opt_leave_run_scripts,
            "handler|H=s" => \$opt_handler,
            "handler_options|O=s" => \$opt_handler_options,
            "list-handlers|l" => \$opt_list_handlers,
            "dry-run|n" => \$opt_dry_run,
            "output|o" => \$opt_output,
            "readme|R" => \$opt_readme,
            "template|t=s" => \$opt_templateemplate,
            "dont-test-for-handler|T" => \$opt_dont_test_for_handler,
            "verbose|v+" => \$opt_verbose,
          ) || pod2usage(-verbose => 2);

# help
if($opt_help)
{
  pod2usage(-verbose => 1);
}
if($opt_manual)
{
  pod2usage(-verbose => 2);
}
if($opt_readme)
{
  write_readme();
  exit(0);
}
if($opt_dry_run)
{
  print "Dry Run. Will just print commands that would be executed instead of executing them.\n";
  print "Note that this may not help much if a temporary script is going to be created an ran.\n\n";
}

$debug         = 1      if ($opt_debug);
$verbose_level = $opt_verbose;
$verbose_level = 100    if ($debug);
$opt_handler_options         = "" unless ($opt_handler_options);


if($opt_list_handlers)
{
  foreach $hdlr ( @handlers )
  {
    print $hdlr->{name}."\t\t- ".$hdlr->{help}."\n";
  }

  exit(0);
}

$opt_debug = ' ' if($opt_args_are_run_scripts);
$arg_delim = $opt_delimiter if($opt_delimiter);





#                 _       
# _ __ ___   __ _(_)_ __  
#| '_ ` _ \ / _` | | '_ \ 
#| | | | | | (_| | | | | |
#|_| |_| |_|\__,_|_|_| |_|

$tempdir = tempdir(CLEANUP => $debug ? 0 : 1) or die "Cannot make temp dir.  Unable to proceed - aborting.";
                         
# get array of commands that need to be ran
@CMDS = split( /\s*$arg_delim\s*/, join(' ', @ARGV) );

# if the -C option was given, then we want to prepend its argument to all commands
if( $opt_command )
{
  @CMDS = map { $opt_command." ".$_} @CMDS;
}

# check if some stdin is being piped in
if( ! -t STDIN)
{
  # if so, pass each item in stdin to all commands as an argument
  foreach $ARG (<STDIN>)
  {
    push @NEWCMDS, map { $_." ".$ARG } @CMDS;
  }
  @CMDS = @NEWCMDS;
}



# try to figure out what handler to use
undef $handler;
my $handler_args = [];
if($opt_handler)
{
  my ($name,$args) = split /:/, $opt_handler;
  @handler_args = split /,/,$args if($args);
  for $hdlr (@handlers)
  {
    if( $hdlr->{name} =~ /$name/ )
    {
      $handler = $hdlr
    }
  }

  if( not defined($handler) )
  {
    print "ERROR: '$name' handler not found. Did you misspell it? Use -l option to see a list of supported handlers";
    exit(1);
  }
}
else
{
  foreach $hdlr ( @handlers )
  {
     message(2, "Checking '$hdlr->{name}' handler..." );
     if( $hdlr->{'func'}->() )
     {
       message(2, "valid\n"  );
       $handler = $hdlr;
       last;
     }
     message(2, "invalid\n"  );
  }
}

if( not defined($handler) )
{
  print "ERROR: no handler was found. Something is wrong\n";
  exit(1);
}

message(1, "Running with '$handler->{name}' handler\n");
if( $debug )
{
  print "running the following commands:\n";
  for my $CMD (@CMDS)
  {
    print "\t'$CMD'\n"
  }
}

$handler->{func}->({args => \@handler_args, cmds => \@CMDS});

if( $opt_leave_run_scripts )
{
  # all scripts will be in tempdir and have the script_prefix.
  opendir(DIR,$tempdir);
  my @files = grep(/^${script_prefix}.*${script_suffix}$/, readdir(DIR) );
  foreach my $file (@files) { copy("${tempdir}/${file}", "${file}"); chmod 0755, ${file}; }
  closedir(DIR);
}


exit(0);

=head1 NAME

run - Quickly queue and run jobs from the command line.

VERSION: 0.2.0

=head1 DESCRIPTION

C<run> is a perl script that will run a set of commands.
It is primarily useful for running commands that are expected to run for a long
time, such as physics simulations.  C<run> uses "handlers" to actually run the
commands, and tries to automatically select the best handler to use to complete
the runs as quickly as possible. For example, if you are working on a cluster
and the C<qsub> command exists, C<run> will create submission scripts and submit
them to the scheduler.  If the C<qsub> command does not exist, then other handlers
are checked. For example, if the C<parallel> (gnu parallel) or C<xjobs> commands
are found, they can be used to run all commands in parallel.

If all other handlers fail, C<run> will fall back to just running each command
in serial, one after the other.  This turns out to still be useful, because if
you have a set of simulations that you need to perform, you can use C<run> to
automatically run each simulation after one has completed.

All handlers will first create a script wrapper for each command to run and
then run this script.  This is done so that extra information can be embedded
in the command output, such as a time stamp for timing data.


=head2 Current Handlers

=over

=item C<qsub>

This handler uses the C<qsub> command. C<qsub> is used to submit jobs to several HPC
schedulers including PBS, MOAB, and SGE. The qsub handler will automatically
create a submission script for each job and subit the scripts to the scheduler.
This is handy if you want to just quickly submit a basic job that does not
require a complex submission script.

=item C<qsub>

This handler uses the C<condor_submit> command to submit jobs to an htcondor
pool. htcondor is a high-throughput computing framework used to manage a set (pool)
of desktop computers and run jobs on idle machines.
See https://research.cs.wisc.edu/htcondor/ for more details.

=item C<gnuparallel>

This handler uses the C<parallel> command, from the gnuparallel project. C<parallel> is a
perl script that runs multiple jobs in parallel and even supports running jobs on remote computers
(not supported by run). It attempts to work as a parallel version of C<xargs>.

=item C<xjobs>

This handler uses the C<xjobs> command. C<xjobs> is a small C program written by Thomas Maier-Komer that
that a command multiple times with different arguments in parallel.
It strives to be a parallel version of C<xargs>.

=item C<serial>

This handler just runs each job directly, one after the other.

=back

=head2 Possible Future Handlers

=over

=item C<pexec>

=back

Note that C<run> does not do load balancing. Each handler is given the list of commands to run, and they are responsible
for managing the system workload.

=head1 USAGE

  > run cmd1 [args] [: cmd2 [args] [...] ]

  If standard input is piped in from another command, then `run` will read
  arguments from stdin and run each command with each argumnet.

  > command that produces list of arguents | run cmd1 [: cmd2 [...] ]

=head2 OPTIONS:

=over

=item C<--help|-h> 

This help message.

=item C<--manual|-m> 

Print full manual.

=item C<--verbose|v>

Increase the verbose level by 1.
  
=item C<--dry-run|-n>

Dry run. Don't execute handler commands, just print them to stdout.

=item C<--handler|-H HANDLER>

Specify the HANDLER to use.

=item C<--handler-opts|-O HANDLER_OPTIONS>

Pass a list of options to the handler command.

=item C<--list-handlers|-l>

List supported handlers.

=item C<--command|-C CMD>

Prepend CMD to all commands before running.

=item C<--delimiter|-d DEL>

Use DEL to delimiter commands (default ':').

=item C<--output|-o>

Send standard output to files. note that what happens here depends on the handler. Some
handlers create a separate file for each command ran, some put all the stdout of all commands
in the same file, while others ignore this option all together and always put stdout in files.

=item C<--leave-run-scripts|-f>

Leave the generated wrapper script in the current working directory.

=item C<--args-are-run-scripts|-F>

Treat all arguments as the names of already existing wrapper scripts and run directly without generating new wrapper scripts.

=item C<--block|-B>

Block until all jobs have finished running (only effects qsub handler).

=item C<--template|-t FILENAME>

Use FILENAME as template for the run script. The template script will be "rendered"
by replacing a few special strings. Your script may all, or none, of these strings:

=item C<--readme|-R>

Generate a README.pod file.

<%CMD%>    The command line (command plus arguments) that is to be run.
<%SCRIPT%> The set of commands that C<run> would execute. These include date
           commands before and after the actual command to be run.
<%NAME%>   A name string generated by run. For short commands, this is just the command
           line with spaces ' ' replaced by underscores. For long commands, this is a
           hash of the command line.

=item C<--dont-test-for-handler|-T>

Do not test scheduler before submitting jobs (qsub handler only).


=back

=head1 EXAMPLES

run 3 scripts

    > run script1.sh : script2.sh : script3.sh

run 3 BTEC runs

    > run BTECthermal config1.btec : BTECthermal config2.btec : BTECthermal config3.btec

or, using the -C option

    > run -C BTECthermal config1.btec : config2.btec : config3.btec

or, using the stdin

    > echo config{1,2,3}.btec | run BTECthermal

run BTEC for all config files in the current directory

    > run -C BTECthermal -d' ' config*.btec

or, using the stdin

    > echo config*.btec | run BTECthermal

run 3 scripts using the gnuparallel handler

    > run -H gnuparallel script1.sh : script2.sh : script3.sh

first create run scripts for three commands, then run these scripts.

    > run -f cmd1 : cmd2 : cmd3
    > run -F run_script-*.sh

get a list of all handlers

    > run -l

=head1 INSTALLATION

C<run> is a single perl script. To install it, just place it somewhere in your PATH.

=head2 DEPENDENCIES

C<run> only uses a few standard Perl modules. These modules should be installed with Perl
and it should not be necessary to install any additional modules.

In addition to this, a few standard Linux commands are used.

=head1 LICENSE

The MIT License (MIT)

Copyright (c) 2015-present CD Clark III

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

=cut

