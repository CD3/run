#!/usr/bin/perl -w

use File::Temp qw/tempfile tempdir/;
use File::Basename;
use Getopt::Std;
use Cwd;

$debug = 1;
# these modules are not needed in general, just when we are debugging.
if($debug)
{
  require Data::Dumper;
  Data::Dumper->import();
}


#       _       _           _                       
#  __ _| | ___ | |__   __ _| | __   ____ _ _ __ ___ 
# / _` | |/ _ \| '_ \ / _` | | \ \ / / _` | '__/ __|
#| (_| | | (_) | |_) | (_| | |  \ V / (_| | |  \__ \
# \__, |_|\___/|_.__/ \__,_|_|   \_/ \__,_|_|  |___/
# |___/                                             


$version = '0.1.0';

%scheduler_templates = (
             'name' => { 'SGE'  => '#$ -N %s'
                       , 'PBS'  => '#PBS -N %s'
                       , 'MOAB' => '#MOAB -N %s' }

           , 'walltime' => { 'SGE'  => '#$ -l h_rt=%s'
                           , 'PBS'  => '#PBS -l walltime=%s'
                           , 'MOAB' => '#MOAB -l walltime=%s' }

           , 'shell' => { 'SGE'  => '#$ -S /bin/bash'
                        , 'PBS'  => ''
                        , 'MOAB' => '' }
           , 'cwd'   => { 'SGE'  => '#$ -cwd'
                        , 'PBS'  => ''
                        , 'MOAB' => '' }
             );

$shebang = "#! ".`which bash`;

$verbose_level = 0;

$arg_delim = ":";

$tempdir = tempdir(CLEANUP => $debug ? 0 : 1) or die "Cannot not make temp dir.  Unable to proceed - aborting.";


#           _                     _   _                 
# ___ _   _| |__  _ __ ___  _   _| |_(_)_ __   ___  ___ 
#/ __| | | | '_ \| '__/ _ \| | | | __| | '_ \ / _ \/ __|
#\__ \ |_| | |_) | | | (_) | |_| | |_| | | | |  __/\__ \
#|___/\__,_|_.__/|_|  \___/ \__,_|\__|_|_| |_|\___||___/
                                                       


sub usage()
{
my $me = basename($0);
print $me." - $version\n";
print <<'EOF';
Run a set of commands, using scheduler if possible.

usage: $me cmd1 [args] [: cmd2 [args] [...] ]

options:

  -h             this help message
  -V LEVEL       set verbose level to LEVEL
  -v             enable verbose level 1
  -H HANDLER     specify the HANDLER to use
  -l             list supported handlers
  -C CMD         prepend CMD to all commands befor running
  -d DEL         use DEL to delimite commands (default '$arg_delim')


EXAMPLES:

run 3 scripts

  > run script1.sh : script2.sh : script3.sh

run 3 BTEC runs

  > run -C BTECthermal config1.btec : config2.btec : config3.btec

run BTEC for all config file in the current directory

  > run -C BTECthermal -d' ' config*.btec

run 3 scripts using the gnuparallel handler

  > run -H gnuparallel script1.sh : script2.sh : script3.sh

get a list of all handlers

  > $me -l

EOF
}

sub cmd_exists
{
  my $cmd = shift;
  my $e = system("which $cmd > /dev/null 2>&1");

  return !$e;
}


sub build_skel_script
{
  my ($CMD) = @_;
  my @lines = ();

  push @lines, $shebang."\n";
  push @lines, "cd ".getcwd()."\n";
  push @lines, "echo -n 'Start: '";
  push @lines , "date +%Y%m%d%H%M%S\n";
  push @lines, $CMD."\n";
  push @lines, "echo -n 'End: '";
  push @lines , "date +%Y%m%d%H%M%S\n";

  return @lines;
}

sub write_script
{
  my    $scriptfn = $tempdir."/run_script-${cmdi}.sh";
  open( $scriptfh,">".$scriptfn) or die "could not write submit script to temp file";
  print $scriptfh join( "\n", @_ )."\n";
  close($scriptfh);

  return $scriptfn;
}

sub message
{
  my $level = shift;
  print "MSG($level): ".join " ", @_  if( $level <= $verbose_level );
}


# _                     _ _               
#| |__   __ _ _ __   __| | | ___ _ __ ___ 
#| '_ \ / _` | '_ \ / _` | |/ _ \ '__/ __|
#| | | | (_| | | | | (_| | |  __/ |  \__ \
#|_| |_|\__,_|_| |_|\__,_|_|\___|_|  |___/
                                         
# all handlers need to follow a special convension: if called with no arguments, return if the handler can handle
# remember that shell commands return 0 ON SUCESS.






#                 _     
#  __ _ ___ _   _| |__  
# / _` / __| | | | '_ \ 
#| (_| \__ \ |_| | |_) |
# \__, |___/\__,_|_.__/ 
#    |_|                

sub qsub {
  if( scalar @_ == 0 ) {
    # first of all, the qsub command needs to exist
    my $e = cmd_exists('qsub');
    
    return 0 if( not $e );

    # but, just because the qsub command exists, does not mean
    # it will work. we can try to submit simple job through the
    # standard input.
    $e = system('echo "hostname" | qsub > /dev/null 2>&1');

    return 0 if( $e );

    # the qsub command exists, and it appears to be accepting commands,
    # so it looks like we can give it the OK.
    return 1;
  }

  # we need ot figure out what scheduler is running so we can create the correct
  # script
  my $scheduler = "UNKNOWN";

  $scheduler = "PBS"  if( cmd_exists( "pbsnodes" ) );
  $scheduler = "MOAB" if( cmd_exists( "moabnodes" ) );
  $scheduler = "SGE"  if( cmd_exists( "sge_qmaster" ) );

  message( 1, "Scheduler detected: $scheduler");


  $cmdi = 0;
  for $CMD (@_)
  {
    $cmdi = $cmdi+1;

    # generate the script that we will submit.
    my @lines = build_skel_script( $CMD );
    my @conf = ();

    push @conf, sprintf( $scheduler_templates{name    }->{$scheduler}, $CMD);
    push @conf, sprintf( $scheduler_templates{walltime}->{$scheduler}, "10:00:00");
    push @conf, sprintf( $scheduler_templates{shell   }->{$scheduler}, "bash");
    push @conf, sprintf( $scheduler_templates{cwd     }->{$scheduler} );
    push @conf, "date";
    push @conf, $CMD;
    push @conf, "date";

    splice @lines, 1, 0, @conf;

    my $scriptfn = write_script( @lines );
    system ("qsub ".$scriptfn);

  }
}


#                                           _ _      _ 
#  __ _ _ __  _   _   _ __   __ _ _ __ __ _| | | ___| |
# / _` | '_ \| | | | | '_ \ / _` | '__/ _` | | |/ _ \ |
#| (_| | | | | |_| | | |_) | (_| | | | (_| | | |  __/ |
# \__, |_| |_|\__,_| | .__/ \__,_|_|  \__,_|_|_|\___|_|
# |___/              |_|                               

sub gnuparallel {
  if( scalar @_ == 0 ) {
    return cmd_exists('parallel');
  }

  my @scripts = ();
  $cmdi = 0;
  for $CMD (@_)
  {
    $cmdi = $cmdi+1;

    my @lines = build_skel_script( $CMD );
    my $scriptfn = write_script( @lines );
    system("chmod +x ".$scriptfn);
    push @scripts, $scriptfn;
  }


  system("parallel ::: ".join(" ", @scripts) );

}


#       _       _         
#__  __(_) ___ | |__  ___ 
#\ \/ /| |/ _ \| '_ \/ __|
# >  < | | (_) | |_) \__ \
#/_/\_\/ |\___/|_.__/|___/
#    |__/                 


#               _       _ 
# ___  ___ _ __(_) __ _| |
#/ __|/ _ \ '__| |/ _` | |
#\__ \  __/ |  | | (_| | |
#|___/\___|_|  |_|\__,_|_|
                         

sub serial {
  if( scalar @_ == 0 ) {
    return 1; # this one will always work
  }

  $cmdi = 0;
  for $CMD (@_)
  {
    $cmdi = $cmdi+1;

    my @lines = build_skel_script( $CMD );
    my $scriptfn = write_script( @lines );
    system("chmod +x ".$scriptfn);
    system($scriptfn);
  }

}










my @handlers  = (
                  { name => "qsub"         , func => \&qsub        , help => "submit jobs to a scheduler" } ,
                  { name => "gnuparallel"  , func => \&gnuparallel , help => "run commands using the the gnu parallel script" } ,
                  { name => "serial"       , func => \&serial      , help => "run jobs one after the other" } ,
                );

#             _   _               _                     _ _ _             
#  ___  _ __ | |_(_) ___  _ __   | |__   __ _ _ __   __| | (_)_ __   __ _ 
# / _ \| '_ \| __| |/ _ \| '_ \  | '_ \ / _` | '_ \ / _` | | | '_ \ / _` |
#| (_) | |_) | |_| | (_) | | | | | | | | (_| | | | | (_| | | | | | | (_| |
# \___/| .__/ \__|_|\___/|_| |_| |_| |_|\__,_|_| |_|\__,_|_|_|_| |_|\__, |
#      |_|                                                          |___/ 

our(
   $opt_h
  ,$opt_l
  ,$opt_H
  ,$opt_v
  ,$opt_d
   );

getopt('HVCd');

# help
if($opt_h)
{
  usage();
  exit(0);
}

if( $opt_V )
{
  $opt_v = $opt_V;
}

$verbose_level = $opt_v if($opt_v);


if($opt_l)
{
  foreach $hdlr ( @handlers )
  {
    print $hdlr->{name}."\t\t- ".$hdlr->{help}."\n";
  }

  exit(0);
}

if($opt_d)
{
  $arg_delim = $opt_d;
}





#                 _       
# _ __ ___   __ _(_)_ __  
#| '_ ` _ \ / _` | | '_ \ 
#| | | | | | (_| | | | | |
#|_| |_| |_|\__,_|_|_| |_|
                         
# get array of commands that need to be ran
@CMDS = split( /\s*$arg_delim\s*/, join(' ', @ARGV) );

# if the -C option was given, then we want to prepend its argument to all commands

if( $opt_C )
{
  @CMDS = map { $opt_C." ".$_} @CMDS;
}




# try to figure out what options we have.
undef $handler;
if($opt_H)
{
  $handler_name = $opt_H;
  for $hdlr (@handlers)
  {
    if( $hdlr->{name} =~ /$handler_name/ )
    {
      $handler = $hdlr
    }
  }

  if( not defined($handler) )
  {
    print "ERROR: '$handler_name' handler not found. Did you misspell it? Use -l option to see a list of supported handlers";
    exit(1);
  }
}
else
{
  foreach $hdlr ( @handlers )
  {
     message(2, "Checking '$hdlr->{name}' handler..." );
     if( $hdlr->{'func'}->() )
     {
       message(2, "valid\n"  );
       $handler = $hdlr;
       last;
     }
     message(2, "invalid\n"  );
  }
}

if( not defined($handler) )
{
  print "ERROR: no handler was found. Something is wrong\n";
  exit(1);
}

message(1, "Running with '$handler->{name}' handler");
$handler->{func}->(@CMDS);


exit(0);

