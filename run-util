#!/usr/bin/perl -w

use File::Temp qw/tempfile tempdir/;
use File::Basename;
use Getopt::Std;
use Cwd;
use List::Util qw/max/;


#       _       _           _                       
#  __ _| | ___ | |__   __ _| | __   ____ _ _ __ ___ 
# / _` | |/ _ \| '_ \ / _` | | \ \ / / _` | '__/ __|
#| (_| | | (_) | |_) | (_| | |  \ V / (_| | |  \__ \
# \__, |_|\___/|_.__/ \__,_|_|   \_/ \__,_|_|  |___/
# |___/                                             

$debug = 0;
$verbose_level = 0;
$VERSION = '0.3.0';

#           _                     _   _                 
# ___ _   _| |__  _ __ ___  _   _| |_(_)_ __   ___  ___ 
#/ __| | | | '_ \| '__/ _ \| | | | __| | '_ \ / _ \/ __|
#\__ \ |_| | |_) | | | (_) | |_| | |_| | | | |  __/\__ \
#|___/\__,_|_.__/|_|  \___/ \__,_|\__|_|_| |_|\___||___/
                                                       


sub usage()
{
my $me = basename($0);
print $me." - $VERSION\n";
print <<'EOF';
A set of useful utilities when running jobs, particularly when using the run command.

commands:
EOF

for $cmd (keys(%commands) )
{
  printf( "\t%-".(max(map{length}keys(%commands)))."s - %s\n", $cmd, $commands{$cmd}{help});
}
}

sub cmd_exists
{
  my $cmd = shift;
  my $e = system("which $cmd > /dev/null 2>&1");

  return !$e;
}

sub import_optional_packages
{
  require Data::Dumper;
  Data::Dumper->import();
}

#                                               _     
#  ___ ___  _ __ ___  _ __ ___   __ _ _ __   __| |___ 
# / __/ _ \| '_ ` _ \| '_ ` _ \ / _` | '_ \ / _` / __|
#| (_| (_) | | | | | | | | | | | (_| | | | | (_| \__ \
# \___\___/|_| |_| |_|_| |_| |_|\__,_|_| |_|\__,_|___/
                                                     

sub time_cmd {
  # we are going to go through all stdout files and build a tree of timing data
  # that we will then report.
  # each file contains the output of one or more jobs. each job will have a command, begin time and end time.
  #
  # the tree will be structures as follows:
  #
  # file :
  #   duration : XX
  #   jobs  :
  #     - begin : XX
  #       end : XX
  #       duration : XX
  #       cmd : XX


  # first we get all files that could be a stdout file from the run command
  opendir(DIR,".");
  my @files = grep(/^.*\.o[0-9]+$/, readdir(DIR) );
  closedir(DIR);

  # now get the timing data out of each file
  my %times= ();
  for my $file (@files)
  {
    open(FILE, "<$file");
    my @alllines = <FILE>;
    close(FILE);

    # get all CMD,BEGIN, and END lines
    my @lines = grep(/CMD|BEGIN|END/, @alllines);

    if( @lines > 0 )
    {
      $times{$file} = { duration => 0, jobs => [] };
    }

    for my $line (@lines)
    {
      if( $line =~ /CMD:\s*(.+)/ )
      {
        push @{$times{$file}->{jobs}}, {cmd=>$1, begin=>0, end=>0, duration=>-1};
      }

      if( $line =~ /BEGIN:\s*([0-9 :]+)/ )
      {
        $times{$file}->{jobs}->[-1]->{begin}    = $1;
      }

      if( $line =~ /END:\s*([0-9 :]+)/ )
      {
        $times{$file}->{jobs}->[-1]->{end}      = $1;

        $times{$file}->{jobs}->[-1]->{duration} = `date +%s --date='$times{$file}->{jobs}->[-1]->{end}'`
                                                - `date +%s --date='$times{$file}->{jobs}->[-1]->{begin}'`;

      }
    }

    # go through all the jobs and tally up run times
    for my $job ( @{ $times{$file}->{jobs} })
    {
      if( $job->{duration} < 0 )
      {
        $job->{duration} = "unfinished";
      }
      else
      {
        $times{$file}->{duration} += $job->{duration}
      }
    }
        

  }


  my $fnw = max(map {length($_)} keys(%times));

  for my $file (keys(%times))
  {
    printf("%-${fnw}s: %s s\n", $file, $times{$file}->{duration});
    for my $job (@{$times{$file}->{jobs}})
    {
      printf("%-${fnw}s : %s s\n" , "\t".$job->{cmd}, $job->{duration});
    }
  }


}

sub clean_cmd {
  
  our($opt_x,
      $opt_h);
  getopt();

  if( $opt_h )
  {
    print <<'EOF';
    options:
      -x        execute the cleaning action. by default, clean performs a 'dry run'
EOF
    return;
  }

  # remove any stdout files that the run command has generated.
  #
  #
  # first, get a list of the files that have the correct name.
  opendir(DIR,".");
  my @files = grep(/^.*\.o[0-9]+$/, readdir(DIR) );
  closedir(DIR);

  # now check that these files actually are stdout files
  for my $file (@files)
  {
    open(FILE, "<$file");
    my @matches = grep(/CMD|BEGIN|END/, <FILE>);
    close(FILE);

    if( $opt_x )
    {
      system("rm $file\n") if( @matches > 2 );
    }
    else
    {
      print("rm $file\n") if( @matches > 2 );
    }
  }
}

sub queue_cmd {
  
  our($opt_x,
      $opt_h);
  getopt();

  if( $opt_h )
  {
    print <<'EOF';
    summarrizes information about the queue. requires 'qstat' command.

    commands:
      who    - print list of all users running/queueing jobs and the number of jobs they have running/queued
      me - print number of jobs ran by ${USER}
      number - print the number of queued jobs

    options:


EOF
    return;
   }

    if( not cmd_exists('qstat') )
    {
      print "ERROR: queue requires the 'qstat' command, which was not found\n";
      return;
    }

    my $cmd = @_ ? shift @_ : "who";

    if( "who" =~ /^$cmd/ )
    {
      system('qstat | gawk \'$4 && $4 != "user" {print $4}\' | sort | uniq -c | sort -g' );
    }

    if( "me" =~ /^$cmd/ )
    {
      system('qstat | gawk \'$4 && $4 != "user" {print $4}\' | grep ${USER} | sort | uniq -c | sort -g' );
    }

    if( "number" =~ /^$cmd/ )
    {
      system('qstat | gawk \'$4 && $4 != "user" {print $4}\' | wc -l' );
    }



    return;
}


sub BTEC_cmd {

  our(
      $opt_h ,
    );
  getopt();

  if( $opt_h )
  {
    print <<'EOF';
    Collect, analyze and report BTEC related information. This command is pretty much useless to anybody that does now
    know what BTEC is.

    commands:
      completed  - list completed jobs
      incomplete - list incomplete jobs

    options:


EOF
    return;
   }

    if( not cmd_exists('qstat') )
    {
      print "ERROR: queue requires the 'qstat' command, which was not found\n";
      return;
    }

    my $cmd = shift @_;

    if( "who" =~ /^$cmd/ )
    {
      system('qstat | gawk \'$4 && $4 != "user" {print $4}\' | sort | uniq -c | sort' );
    }

    if( "number" =~ /^$cmd/ )
    {
      system('qstat | gawk \'$4 && $4 != "user" {print $4}\' | wc -l' );
    }



    return;

}


%commands  = (
               time  => { func => \&time_cmd,  help => "collect information about run times." },
               clean => { func => \&clean_cmd, help => "clean files created by the run command." },
               queue => { func => \&queue_cmd, help => "print information about the queue. accepts sub-commands. run 'queue -h.' for more information." },
               BTEC  => { func => \&BTEC_cmd,  help => "BTEC related information." },
             );




#                 _       
# _ __ ___   __ _(_)_ __  
#| '_ ` _ \ / _` | | '_ \ 
#| | | | | | (_| | | | | |
#|_| |_| |_|\__,_|_|_| |_|

$tempdir = tempdir(CLEANUP => $debug ? 0 : 1) or die "Cannot make temp dir.  Unable to proceed - aborting.";
                         

our(
  $opt_h ,
  $opt_v ,
  $opt_V ,
  $opt_D ,
   );

getopt('V');

# help
if($opt_h or not @ARGV)
{
  usage();
  exit(0);
}

$debug         = 1      if ($opt_D);
$opt_v         = $opt_V if ($opt_V);
$verbose_level = $opt_v if ($opt_v);
$verbose_level = 100    if ($debug);


if( $debug )
{
  import_optional_packages();
}


$cmd_str = shift;


undef $cmd;
@matches = grep( /^$cmd_str/, keys(%commands) );
if( @matches < 2 )
{
  $cmd = $commands{$cmd_str};
}

if( defined( $cmd ) )
{
  $cmd->{func}->(@ARGV);
}
else
{
 print "Error: '$cmd_str' is not a reconized command. Did you mispell it?\n"     if( @matches < 2 );
 if( @matches > 1 )
 {
   print "Error: '$cmd_str' matches multiple commands:\n";
   print "\t".join("\n\t", @matches)."\n\n";
   print "Please be more specific.\n";
 }
 print "\n";
 usage();
 exit(1);
}

exit(0);

